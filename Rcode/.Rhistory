#####
# initial state
x_current <- c(0,0,0)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as x[1], x[2], x[3]
x_next <- c(
x_current[2],
x_current[1]*x_current[3],
(1-x_current[1])
)
x_current <- x_next
}
# initial state
x_current <- c(1,1,1)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as x[1], x[2], x[3]
x_next <- c(
x_current[2],
x_current[1]*x_current[3],
(1-x_current[1])
)
x_current <- x_next
}
# initial state
x_current <- c(0,1,1)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as x[1], x[2], x[3]
x_next <- c(
x_current[2],
x_current[1]*x_current[3],
(1-x_current[1])
)
x_current <- x_next
}
# initial state
x_current <- c(0,0,0)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as x[1], x[2], x[3]
x_next <- c(
x_current[2],
x_current[1]+x_current[3]-x_current[1]*x_current[3],
x_current[1]*x_current[2]+x_current[3]-x_current[1]*x_current[2]*x_current[3]
)
x_current <- x_next
}
x_current <- c(1,0,0)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as x[1], x[2], x[3]
x_next <- c(
x_current[2],
x_current[1]+x_current[3]-x_current[1]*x_current[3],
x_current[1]*x_current[2]+x_current[3]-x_current[1]*x_current[2]*x_current[3]
)
x_current <- x_next
}
x_current <- c(1,0,1)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as x[1], x[2], x[3]
x_next <- c(
x_current[2],
x_current[1]+x_current[3]-x_current[1]*x_current[3],
x_current[1]*x_current[2]+x_current[3]-x_current[1]*x_current[2]*x_current[3]
)
x_current <- x_next
}
A<-matrix(c(
0.95,    0,    0,
0.05,   0.88,     0,
0,   0.12,   1
),nrow=3, byrow=TRUE)
A
eigen(A)
# For only eigenvalue
eigen(A)$values
# For only eigenvectors
eigen(A)$vectors
# For dominant eigenvalue
max(Re(eigen(A)$values))
# or
eigen(A)$values[1]
# with dominant eigenvector
eigen(A)$vectors[,1]
eigen(A)$vectors[,1]/sum(eigen(A)$vectors[,1])
## Math 265 - Loggerhead sea turtle model
# Assume that the sea turtle passes through 7 stages
# Egg/Hatchling, small juvenile, large juvenile, sub-adult, novice breed,
# 2nd-time breeders, mature adult
# The Projection matrix for sea turtle data
A <-matrix(c(
0,      0,        0,       0,       127,     4,    80,
0.6747, 0.7370,   0,       0,         0,     0,     0,
0,      0.0486,  0.6610,   0,         0,     0,     0,
0,      0,       0.0147,   0.6907,    0,     0,     0,
0,      0,        0,       0.0518,    0,     0,     0,
0,      0,        0,       0,      0.8091,   0,     0,
0,      0,        0,       0,        0,   0.8091,  0.8089),
nrow=7, byrow=TRUE)  # since there are 7 stages
# The commands below will label the rows and columns by stages
stage_names <- c("Hatchling","Small Juv","Large Juv","Subadult","Novice Breed",
"2nd-Timer","Adult")
rownames(A) <- stage_names
colnames(A) <- stage_names
A   # to display the projection matrix A
## How many sea turtles of each class would you expect to see next year?
pop_year0 <- c(10,10,10,10,10,10,10) # c() combines the numbers into a vector
pop_year1 <- A %*% pop_year0
pop_year1
## How many total sea turtles would you expect to see next year (in year 1)?
## What proportion are at each stage?
total_year1<- sum(pop_year1)
total_year1
pop_year1/total_year1
## How many total sea turtles would you expect to see each year for the next 10 years (in years 1-10)?
n_years <- 10                     # set the number of years to project
proj_mat <- A                     # define the projection matrix
init_pop <- pop_year0             # define the initial population size
## NOTE: The code below can be re-used without modification:
# First we build a storage array (matrix) for all populations!
all_years <- matrix(0,nrow=nrow(proj_mat),ncol=n_years+1) # nrow means number of rows
all_years[,1] <- init_pop  # set the year 0 population
# Here is the model at work:
for(t in 1:(n_years)){   # iterate (loop) through all years
all_years[,t+1] <-  proj_mat %*% all_years[,t]
}
# adds names to rows and columns of all_years matrix
# each column is the predicted populations of each stages (the rows)
years_names <- 0:n_years
rownames(all_years) <- stage_names
colnames(all_years) <- years_names
all_years
n_new <- sweep(all_years, 2, colSums(all_years),  FUN = "/")
n_new
? sweep
A<-matrix(c(
0.95,    0,    0,
0.05,   0.88,     0,
0,   0.12,   1
),nrow=3, byrow=TRUE)
A
eigen(A)
# For only eigenvalue
eigen(A)$values
# For only eigenvectors
eigen(A)$vectors
time_steps <- 5
time_steps <- 8
# Define parameters
Ge <- 0
Le <- 0
# initial state
x_current <- c(0,0,1)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as x[1], x[2], x[3]
x_next <- c(
(1-Ge)*(x_current[2]*x_current[3]),
x_current[1]*Le,
Lem*x_current[1]+Le-Lem*x_current[1]*Le
)
x_current <- x_next
}
x_current <- c(0,0,1)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as
# x[1] = M, x[2] = E, x[3] = L
x_next <- c(
(1-Ge)*(x_current[3]+Le-x_current[3]*Le),
x_current[1],
(1-Ge)*(x_current[2]*Le+x_current[3]*(1-x_current_[2])-x_current[2]*Le*x_current[3]*(1-x_current[2]))
)
x_current <- x_next
}
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as
# x[1] = M, x[2] = E, x[3] = L
x_next <- c(
(1-Ge)*(x_current[3]+Le-x_current[3]*Le),
x_current[1],
(1-Ge)*(x_current[2]*Le+x_current[3]*(1-x_current[2])-x_current[2]*Le*x_current[3]*(1-x_current[2]))
)
x_current <- x_next
}
time_steps <- 8
# Define parameters
Ge <- 0
Le <- 0
# initial state
x_current <- c(0,1,1)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as
# x[1] = M, x[2] = E, x[3] = L
x_next <- c(
(1-Ge)*(x_current[3]+Le-x_current[3]*Le),
x_current[1],
(1-Ge)*(x_current[2]*Le+x_current[3]*(1-x_current[2])-x_current[2]*Le*x_current[3]*(1-x_current[2]))
)
x_current <- x_next
}
time_steps <- 8
# Define parameters
Ge <- 1
Le <- 0
# initial state
x_current <- c(0,1,1)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as
# x[1] = M, x[2] = E, x[3] = L
x_next <- c(
(1-Ge)*(x_current[3]+Le-x_current[3]*Le),
x_current[1],
(1-Ge)*(x_current[2]*Le+x_current[3]*(1-x_current[2])-x_current[2]*Le*x_current[3]*(1-x_current[2]))
)
x_current <- x_next
}
time_steps <- 8
# Define parameters
Ge <- 0
Le <- 1
# initial state
x_current <- c(0,1,1)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as
# x[1] = M, x[2] = E, x[3] = L
x_next <- c(
(1-Ge)*(x_current[3]+Le-x_current[3]*Le),
x_current[1],
(1-Ge)*(x_current[2]*Le+x_current[3]*(1-x_current[2])-x_current[2]*Le*x_current[3]*(1-x_current[2]))
)
x_current <- x_next
}
time_steps <- 8
# Define parameters
Ge <- 0
Le <- 0
# initial state
x_current <- c(0,0,1)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as
# x[1] = M, x[2] = E, x[3] = L
x_next <- c(
(1-Ge)*(x_current[3]+Le-x_current[3]*Le),
x_current[1],
(1-Ge)*(x_current[2]*Le+x_current[3]*(1-x_current[2])-x_current[2]*Le*x_current[3]*(1-x_current[2]))
)
x_current <- x_next
}
time_steps <- 8
# Define parameters
Ge <- 0
Le <- 0
# initial state
x_current <- c(0,1,1)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as
# x[1] = M, x[2] = E, x[3] = L
x_next <- c(
(1-Ge)*(x_current[3]+Le-x_current[3]*Le),
x_current[1],
(1-Ge)*(x_current[2]*Le+x_current[3]*(1-x_current[2])-x_current[2]*Le*x_current[3]*(1-x_current[2]))
)
x_current <- x_next
}
time_steps <- 8
# Define parameters
Ge <- 1
Le <- 0
# initial state
x_current <- c(1,0,0)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as
# x[1] = M, x[2] = E, x[3] = L
x_next <- c(
(1-Ge)*(x_current[3]+Le-x_current[3]*Le),
x_current[1],
(1-Ge)*(x_current[2]*Le+x_current[3]*(1-x_current[2])-x_current[2]*Le*x_current[3]*(1-x_current[2]))
)
x_current <- x_next
}
time_steps <- 8
# Define parameters
Ge <- 0
Le <- 1
# initial state
x_current <- c(0,0,0)
for (i in 1:time_steps) {
print(x_current)
# Note we can refer to the components of x as
# x[1] = M, x[2] = E, x[3] = L
x_next <- c(
(1-Ge)*(x_current[3]+Le-x_current[3]*Le),
x_current[1],
(1-Ge)*(x_current[2]*Le+x_current[3]*(1-x_current[2])-x_current[2]*Le*x_current[3]*(1-x_current[2]))
)
x_current <- x_next
}
A<-matrix(c(
0.76,    0.01,    0,   0,
0.22,    0.96,  0.01,   0,
0.02,       0.03,  0.85,   0.02,
0,    0,    0.14,   0.98
), nrow = 4, byrow=TRUE)
eigen(A)
# For only eigenvalue
eigen(A)$values
# For only eigenvectors
eigen(A)$vectors
# For dominant eigenvalue
max(Re(eigen(A)$values))
# or
eigen(A)$values[1]
# with dominant eigenvector
eigen(A)$vectors[,1]
eigen(A)$vectors[,1]/sum(eigen(A)$vectors[,1])
.02/365
A<-matrix(c(
0.9999452,    0,    0,
0.0000548,   0.714,     0.029,
0,   0.029,   0.971
),nrow=3, byrow=TRUE)
A
eigen(A)
# For only eigenvalue
eigen(A)$values
# For only eigenvectors
eigen(A)$vectors
# For dominant eigenvalue
max(Re(eigen(A)$values))
# or
eigen(A)$values[1]
# with dominant eigenvector
eigen(A)$vectors[,1]
eigen(A)$vectors[,1]/sum(eigen(A)$vectors[,1])
28*25
144-4*24
(12-sqrt(48))/2
bird.data <- data.frame(
"distance" = c(5,10,15,20,25,30,35,40),
"density" = c(0.275,0.1725,0.09375,0.035,0.0225,0.006,0.005, 0.0025)
)
head(bird.data)
plot(bird.data)
exp.model <- lm(log(density) ~ distance, data = bird.data)
exp.model$coefficients
p_x.exp <- function(x)
{
return(exp.model$coefficients[1]*exp.model$coefficients[2]^x)
}
distance <- seq(0,40,0.1)
plot(bird.data$distance, bird.data$density,  pch=16)
lines(distance, p_x.exp(distance), lwd =2, col='green')
lines(distance, p_x.exp(distance), lwd =2, col='green')
plot(bird.data$distance, bird.data$density,  pch=16)+
lines(distance, p_x.exp(distance), lwd =2, col='green')
p_x.exp(distance)
exp.model$coefficients
p_x.exp <- function(x)
{
return(exp(exp.model$coefficients[1] + exp.model$coefficients[2]*x)
}
distance <- seq(0,40,0.1)
plot(bird.data$distance, bird.data$density,  pch=16)
lines(distance, p_x.exp(distance), lwd =2, col='green')
p_x.exp <- function(x)
{
return(exp(exp.model$coefficients[1] + exp.model$coefficients[2]*x))
}
distance <- seq(0,40,0.1)
plot(bird.data$distance, bird.data$density,  pch=16)
lines(distance, p_x.exp(distance), lwd =2, col='green')
e^(-.14118*40)
exp(-.14118*40)
-(1/.14118)*40*exp(-.14118*40)
-(1/.14118)*40*exp(.14118*40)
-(1/.14118)*40*exp(-.14118*40)
40/.14118
exp.model$coefficients
distance <- seq(0,40,0.1)
plot(bird.data$distance, bird.data$density,  pch=16)
lines(distance, p_x.exp(distance), lwd =2, col='green')
(5^5/6^5)/(5/6)
(5^5/6^5)/(1/6)
(5^5/6^5)
(5^5)
(6^5)
3600*4
(-40)*(-80)-400
4*(26*(40+4)*41*32−(19004+0.71*26*(40+4)*32*41+12(289*(41+5)+2*(41*40*25.68+5*40*19.26))))
4*(26*(40+4)*41*32-(19004+0.71*26*(40+4)*32*41+12(289*(41+5)+2*(41*40*25.68+5*40*19.26))))
4*(26*(40+4)*41*32-(19004+0.71*26*(40+4)*32*41+12*(289*(41+5)+2*(41*40*25.68+5*40*19.26))))
4*(26*(40+4)*41*32-(1900/4+0.71*26*(40+4)*32*41+1/2*(289*(41+5)+2*(41*40*25.68+5*40*19.26))))
4⋅101⋅8⋅0.01⋅816215.6
4*101*8*0.01*816215.6
4*101*8*0.01*816215.6*9*0.01/12/(1-(1+9*0.01/12)^(-12*15))*12*15
48161595-26380088
setwd("~/Documents/research/gizzard_shad/Rcode")
## IPM for Gizzard Shad (Fall 2021)
# Remember to set the working directory:
# Session -> Set Working Directory -> To Source Location
library(tidyverse)  #used to make pretty graphs
library(lubridate) # used to change date format of data
library(reshape2)
##############################################################
## Section 1 - Define the demographic functions and parameters
##############################################################
# Estimating parameters from data
source("gizshad_parameter_estimation.R")
m_par <- tibble(
## growth from Michaletz (2017) paper - Table 1
grow_rate = 0.26, # growth rate
grow_max  =   394.3, # maximum length in mm: L_inf = 394.30
grow_sd   =   25,  # growth sd (Max TL - L_inf)
surv_min  =  0.002, # min survival - Bodola (1955)
# Then et al (2015): surv_max computed from
# 1-natural mortality = 1 - 8.872*K^.73 L^-.33
surv_max = 1 - 8.872*grow_rate^.73*grow_max^(-.33),
# inflection point: will be temp dependent
# computed for La Grange Reach
surv_alpha = 80.0136,
surv_beta = -139.9312, # slope
## New recruit from Michaletz (2017)
recruit_mean = 105,
recruit_sd = 25, # same as grow_sd
## From Bodola (1955):
egg_viable = 0.002,
## Estimated from Jons and Miranda (1997)
egg_slope = coef(egg_extended_nls)[2], # -4.361915
egg_max =  coef(egg_extended_nls)[1], # 41540.608025
egg_infl = coef(egg_extended_nls)[3], # 935.528239
## Spawning Probability - Estimated from Michaletz (2009)
prob_spawn = 0.90,
surv0_int = coef(surv_den_exp)[1], # 0.2686
surv0_decay = coef(surv_den_exp)[2], # 0.0030
)
##########################
## Section 2: Model Set-up
##########################
## Growth function
# Given you are size z now returns the pdf of size z1 next time
#  - Computed from von Bertanaffy equation z(t) = L_inf(1-e^K(t-t0))
# -  To find z(t+1) = L_inf*(1-e^(-K)) + e^(-K)*z(t)
g_z1z <- function(z1, z, m_par) {
mu <- m_par$grow_max * (1 - exp(- m_par$grow_rate)) +
exp(-m_par$grow_rate) * z           # mean size next year
sig <- m_par$grow_sd                       # sd about mean
p_den_grow <- dnorm(z1, mean = mu, sd = sig)    # pdf that you are size z1
# given you were size z
return(p_den_grow)
}
## Adult Survival function, 4-parameter logistic
s_z <- function(z, m_par) {
m_par$surv_min + (m_par$surv_max - m_par$surv_min) /
(1 + exp(m_par$surv_beta * (log(z) - log(m_par$surv_alpha))))
}
## Reproduction, 3-parameter logistic
eggs_z <- function(z, m_par) { # Eggs produced (note: data are in thousands)
return(1000 * m_par$egg_max / (1
+ exp(m_par$egg_slope*
(log(z)-log(m_par$egg_infl)))))
}
## Recruit size pdf
c_1z1 <- function(z1, m_par) {
mu <- m_par$recruit_mean
sig <- m_par$recruit_sd
p_den_recruit <- dnorm(z1, mean = mu, sd = sig)
p_den_recruit <- p_den_recruit / (sum(p_den_recruit) * delta_z)
return(p_den_recruit)
}
#####################################################
## Section 3 - Functions to build IPM kernels F and P
#####################################################
## Fecundity Kernel
# Density-depoendent age-0 survival
surv_density <- function(d, m_par) { # probability of survival of age-0 fish dependent
# on density
return(m_par$surv0_int * exp(- m_par$surv0_decay * d))
}
surv_age0 <- function(n, z, m_par) { # survival age-0
# distribution of VIABLE age0 from current population n
age0_dist <- m_par$egg_viable * eggs_z(z, m_par) *
m_par$prob_spawn * n
age0_density <- 10 ** (-3) * (sum(age0_dist * delta_z))
return(surv_density(age0_density, m_par))
}
f_z1z <- function(z1, z, n, m_par) {
age1_dist <- m_par$prob_spawn * eggs_z(z, m_par) *
m_par$egg_viable * surv_age0(n, z, m_par)
#returns fecundity kernel (as a matrix). Recruits= F.dot(n*delta_z)
return(outer(c_1z1(z1, m_par), age1_dist))
}
## Growth and Survival Kernel
p_z1z <- function(z1, z, m_par) {
g_matrix <- matrix(0, N, N)
for (x in 1:N) {
g_matrix[, x] <- g_z1z(z, rep(z[x], times = N), m_par)
g_matrix[, x] <- g_matrix[, x] / (sum(g_matrix[, x]) * delta_z)
}
return(g_matrix %*% diag(s_z(z, m_par)))
}
